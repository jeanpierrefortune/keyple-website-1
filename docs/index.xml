<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Global Architecture of Keyple | Eclipse Keyple</title><link>/keyple-website/docs/</link><atom:link href="/keyple-website/docs/index.xml" rel="self" type="application/rss+xml"/><description>Global Architecture of Keyple</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright © Eclipse Foundation, Inc. All Rights Reserved.</copyright><lastBuildDate>Thu, 25 Jun 2020 00:00:00 +0000</lastBuildDate><image><url>/keyple-website/images/logo_hud2fb0b35622057c5c7bb20829420fe80_179328_300x300_fit_lanczos_2.png</url><title>Global Architecture of Keyple</title><link>/keyple-website/docs/</link></image><item><title>Get Started with Keyple-Java</title><link>/keyple-website/docs/build-your-first-app-android/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/build-your-first-app-android/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>Keyple SDK is supported by the Operating System Android. As Keyple request low level reader access, the key features of
the SDK relies on components called &amp;lsquo;Plugins&amp;rsquo;.&lt;/p>
&lt;p>Keyple Android Plugins are low level implementation of Keyple contracts described in the section &amp;lsquo;Develop a plugin&amp;rsquo; in Developer
guide. Once a plugin is provided, any classic Android application can use Keyple to provide ticketing features.&lt;/p>
&lt;p>This Guide will describe how to start a ticketing application using Keyple SDK.&lt;/p>
&lt;h2 id="compatibility">Compatibility&lt;/h2>
&lt;ul>
&lt;li>Android OS 19+&lt;/li>
&lt;/ul>
&lt;h1 id="integration">Integration&lt;/h1>
&lt;h2 id="sdk-integration">SDK Integration&lt;/h2>
&lt;h3 id="keyple-core">Keyple Core&lt;/h3>
&lt;p>This high-level API is convenient for developers implementing smart card processing application for terminal interfaced
with smart card readers. Access to the readers is provided by the plugins.&lt;/p>
&lt;p>To use Keyple core API (and in fact, anything keyple&amp;rsquo;s related) import the jar within the gradle dependencies of your
Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-core:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Please refer to Architecture/Keyle Core&lt;/p>
&lt;h3 id="keyple-plugins">Keyple Plugins&lt;/h3>
&lt;p>There are many Keyple plugins available, the one to use depends on the device and ticketing tools you are aiming to
use.&lt;/p>
&lt;p>For a standard device the keyple-android-plugin-nfc and keyple-android-plugin-omapi should be be used. They will allow keyple to
connect to, respectively, a smart card in the NFC field of the device or, a smart card inserted in a SIM like port. The
plugins for Android are Android Libraries (AAR).&lt;/p>
&lt;p>To use the plugins simply import it within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-android-plugin-omapi:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="keyple-calypso">Keyple Calypso&lt;/h3>
&lt;p>The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Object securely using
Calypso SAM.&lt;/p>
&lt;p>Please refer to Architecture/Keyle Calypso&lt;/p>
&lt;p>To use Keyple Calypso User API simply import the jar within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-android-plugin-omapi:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="initializing-the-sdk">Initializing the SDK&lt;/h2>
&lt;h3 id="register-a-plugin">Register a plugin&lt;/h3>
&lt;p>The Singleton SeProxyService is the entry point of the SE Proxy Service, its instance has to be called by a
ticketing application in order to establish a link with a SE’s application.&lt;/p>
&lt;p>In order to access to SE we have to register at least one plugin.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
/* register Omapi Plugin to the SeProxyService */
try {
SeProxyService.getInstance().registerPlugin(AndroidOmapiPluginFactory(this))
} catch (e: KeyplePluginInstantiationException) {
/* do something with it */
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-the-readers">Retrieve the readers&lt;/h3>
&lt;p>With the plugin registered we can retrieve all instance of the component mapping the smartcard readers provided by this
plugins. For example, some plugins provide access to contact and contactless readers)&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//PLUGIN_NAME is a constant provided by the keyple plugin
val readers = SeProxyService.getInstance().getPlugin(PLUGIN_NAME).readers
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-one-specific-reader">Retrieve one specific reader&lt;/h3>
&lt;p>It is also possible to retrieve a specific reader.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//PLUGIN_NAME and READER_NAME are constants provided by the used keyple plugin
val reader = SeProxyService.getInstance().getPlugin(PLUGIN_NAME).getReader(READER_NAME)
&lt;/code>&lt;/pre>
&lt;h2 id="select-a-po">Select a PO&lt;/h2>
&lt;h3 id="seproxy-api">SeProxy API&lt;/h3>
&lt;p>Using a reader, it is possible to select a PO using its AID. Here we use the low level SeProxy API of Keyple core to do so.&lt;/p>
&lt;pre>&lt;code class="language-kotlin"> /*
* Configuration of the selector
* Setting of an AID based selection of a Calypso REV3 PO
*/
val seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO7816_3)
.aidSelector(AidSelector.builder().aidToSelect(poAid).build())
.build()
//build the request by passing the seSelector.
//As second parameter of the SeRequest consctructor, an APDU can be added to be executed
//right after the selection.
val seRequest = SeRequest(seSelector, null)
//A ProxyReader is a physical reader, it allows to send and receive synchronised APDUS
val seResponse = (reader.value as ProxyReader).transmitSeRequest(seRequest, ChannelControl.KEEP_OPEN)
//Check is selection is successful
if (seResponse?.selectionStatus?.hasMatched() == true) {
//Selection is done
} else {
//Selection failed
}
&lt;/code>&lt;/pre>
&lt;h3 id="selection-api">Selection API&lt;/h3>
&lt;p>The bellow example illustrates the same operation using the Selection API, an higher level API of Keyple Core.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">var seSelection = SeSelection()
/*
* Close the channel after the selection
*/
seSelection.prepareReleaseSeChannel()
/*
* AID based selection: get the first application occurrence matching the AID, keep the
* physical channel open
*/
seSelection.prepareSelection(GenericSeSelectionRequest(
SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(AidSelector.builder()
.aidToSelect(seAidPrefix)
.fileOccurrence(AidSelector.FileOccurrence.FIRST)
.fileControlInformation(AidSelector.FileControlInformation.FCI).build())
.build()))
seSelection.prepareSelection(poSelectionRequest)
/*
* Execution og the selection
*/
val selectionsResult = seSelection.processExplicitSelection(reader)
/**
* Check if PO has been selected successfuly
*/
if (selectionsResult.hasActiveSelection()) {
//Selection is done
val matchedSe = selectionsResult.activeMatchingSe
val fci = matchedSe.fciBytes
val atr = matchedSe.atrBytes
} else {
//Selection failed
}
&lt;/code>&lt;/pre>
&lt;h2 id="reading-and-writing-data">Reading and writing data&lt;/h2>
&lt;h3 id="reading-environment-and-usage">Reading Environment and usage&lt;/h3>
&lt;p>Exemple of reading Environmement and usage data of an Hoplink application. As Hoplink is a calypso application, we can map
cast the result of the selection with CalypsoPo. It will allow us to easily access calypso datas.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">var poAid= &amp;quot;A000000291A000000191&amp;quot;
val sfiHoplinkEFEnvironment = 0x14.toByte()
val sfiHoplinkEFUsage = 0x1A.toByte()
/*
* Prepare a Calypso PO selection
*/
val seSelection = SeSelection()
/*
* Setting of an AID based selection of a Calypso REV3 PO
*
* Select the first application matching the selection AID whatever the SE
* communication protocol keep the logical channel open after the selection
*/
/*
* Calypso selection: configures a PoSelectionRequest with all the desired
* attributes to make the selection and read additional information afterwards
*/
val poSelectionRequest = PoSelectionRequest(
PoSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO7816_3)
.aidSelector(AidSelector.builder().aidToSelect(poAid).build())
.invalidatedPo(InvalidatedPo.REJECT).build())
/*
* Prepare the reading order and keep the associated parser for later use once
* the selection has been made.
*/
poSelectionRequest.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1)
poSelectionRequest.prepareReadRecordFile(
sfiHoplinkEFUsage, 1)
/*
* Add the selection case to the current selection (we could have added other
* cases here)
*
* Ignore the returned index since we have only one selection here.
*/
seSelection.prepareSelection(poSelectionRequest)
/*
* Actual PO communication: operate through a single request the Calypso PO
* selection and the file read
*/
try {
val selectionsResult = seSelection.processExplicitSelection(seReader)
if (selectionsResult.hasActiveSelection()) {
val calypsoPo = selectionsResult.activeMatchingSe as CalypsoPo
val environmentAndHolder = calypsoPo.getFileBySfi(sfiHoplinkEFEnvironment).data.content
val usage = calypsoPo.getFileBySfi(sfiHoplinkEFUsage).data.content
} else {
//The selection of the PO Failed
}
} catch (e: Exception) {
//The selection of the PO Failed with an error
}
&lt;/code>&lt;/pre>
&lt;h3 id="incrementing-a-counter">Incrementing a counter&lt;/h3>
&lt;p>In this example, we&amp;rsquo;ll increase Counter 1 by 10 on a contactless ticketing NFC PO. The counter will be increased
when the PO will enter NFC Field.&lt;/p>
&lt;h4 id="setup-to-catch-reader-event">Setup to catch reader event&lt;/h4>
&lt;pre>&lt;code class="language-kotlin">/*
* In order to received readers events (Inserted, removed etc..), the interface ObservableReader.ReaderObserver must be
* implemented.
*
*/
import org.eclipse.keyple.core.seproxy.event.ObservableReader
import org.eclipse.keyple.core.seproxy.event.ReaderEvent
class MainActivity : ObservableReader.ReaderObserver{
//Initialise Android NFC Reader
override fun initReaders() {
// Initialize SEProxy with Android Plugins
val nfcPlugin = SeProxyService.getInstance().registerPlugin(AndroidNfcPluginFactory())
//Example of plugin for device with a sam reader
val samPlugin = SeProxyService.getInstance().registerPlugin(AndroidFamocoPluginFactory())
// Configuration of AndroidNfc Reader
poReader = nfcPlugin.getReader(AndroidNfcReader.READER_NAME) as AndroidNfcReader
poReader.setParameter(&amp;quot;FLAG_READER_RESET_STATE&amp;quot;, &amp;quot;0&amp;quot;)
poReader.setParameter(&amp;quot;FLAG_READER_PRESENCE_CHECK_DELAY&amp;quot;, &amp;quot;100&amp;quot;)
poReader.setParameter(&amp;quot;FLAG_READER_NO_PLATFORM_SOUNDS&amp;quot;, &amp;quot;0&amp;quot;)
poReader.setParameter(&amp;quot;FLAG_READER_SKIP_NDEF_CHECK&amp;quot;, &amp;quot;0&amp;quot;)
(poReader as ObservableReader).addObserver(this)
(poReader as ObservableReader).addSeProtocolSetting(SeCommonProtocols.PROTOCOL_ISO14443_4,
AndroidNfcProtocolSettings.getSetting(SeCommonProtocols.PROTOCOL_ISO14443_4))
}
// Reader event will be caught in this method
override fun update(event: ReaderEvent?) {
CoroutineScope(Dispatchers.Main).launch {
when (event?.eventType) {
ReaderEvent.EventType.SE_MATCHED -&amp;gt; {
//PO with set AID detected
samReader.setParameter(AndroidFamocoReader.FLAG_READER_RESET_STATE, &amp;quot;&amp;quot;)
val samResource = checkSamAndOpenChannel(samReader)
val selectionsResult = seSelection.processDefaultSelection(event.defaultSelectionsResponse)
if (selectionsResult.hasActiveSelection()) {
val calypsoPo = selectionsResult.activeMatchingSe as CalypsoPo
val poTransaction = PoTransaction(SeResource(poReader, calypsoPo), getSecuritySettings(samResource))
when (transactionType) {
TransactionType.INCREASE -&amp;gt; {
/*
* Open Session for the debit key
*/
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_LOAD)
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Counter1, CalypsoClassicInfo.RECORD_NUMBER_1.toInt())
poTransaction.processPoCommandsInSession()
//Process PO increase counter by 10
poTransaction.prepareIncreaseCounter(CalypsoClassicInfo.SFI_Counter1, CalypsoClassicInfo.RECORD_NUMBER_1.toInt(), 10)
poTransaction.processClosing(ChannelControl.CLOSE_AFTER)
addResultEvent(&amp;quot;Increase by 10: SUCCESS&amp;quot;)
}
}
}
//Notifying Keyple that we handled event
(poReader as ObservableReader).notifySeProcessed()
}
ReaderEvent.EventType.SE_INSERTED -&amp;gt; {
//PO detected but AID didn't match with AID set
//Notifying Keyple that we handled event
(poReader as ObservableReader).notifySeProcessed()
}
ReaderEvent.EventType.SE_REMOVED -&amp;gt; {
//Action when SE is Removed
}
ReaderEvent.EventType.TIMEOUT_ERROR -&amp;gt; {
//Action when timeout with SE
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="launch-detection">Launch detection&lt;/h4>
&lt;pre>&lt;code class="language-kotlin"> /* Prepare a Calypso PO selection */
val seSelection = SeSelection(MultiSeRequestProcessing.FIRST_MATCH)
/* Calypso selection: configures a PoSelector with all the desired attributes to make the selection and read additional information afterwards */
val poSelectionRequest = PoSelectionRequest(PoSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(SeSelector.AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build())
.invalidatedPo(PoSelector.InvalidatedPo.REJECT).build())
/* Prepare the reading order */
poSelectionRequest.prepareReadRecordFile(CalypsoClassicInfo.SFI_EnvironmentAndHolder, CalypsoClassicInfo.RECORD_NUMBER_1.toInt())
/*
* Add the selection request to the current selection (we could have added other request
* here)
*/
seSelection.prepareSelection(poSelectionRequest)
/*
* Provide the SeReader with the selection operation to be processed when a PO is
* inserted.
*/
(poReader as ObservableReader).setDefaultSelectionRequest(seSelection.selectionOperation,
ObservableReader.NotificationMode.MATCHED_ONLY)
// notify reader that se detection has been launched
poReader.startSeDetection(ObservableReader.PollingMode.REPEATING)
&lt;/code>&lt;/pre>
&lt;p>#FAQ:&lt;/p>
&lt;p>When should I use the Selection API instead of SeProxy API?&lt;/p></description></item><item><title>Get Started with Keyple-Java</title><link>/keyple-website/docs/build-your-first-app-java/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/build-your-first-app-java/</guid><description>&lt;p>This getting stated contains one ready-to-execute JAVA example starting from a new Gradle project.&lt;/p>
&lt;p>The example demonstrate Keyple capabilities with the Keyple PCSC plugin and PO/SAM provided in the Calypso Test Kit.&lt;/p>
&lt;h2 id="build">Build&lt;/h2>
&lt;p>The example can run on any machine: Linux, Windows and MacOS. If not installed in your machine, you will need to download :&lt;/p>
&lt;p>Java 1.6 or newer&lt;/p>
&lt;p>Gradle (any version) download&lt;/p>
&lt;p>We recommend that you use a Java IDE like Eclipse or Intellij to create your new Gradle project.&lt;/p>
&lt;p>Create a new Gradle project.&lt;/p>
&lt;p>Add the following statements to your build.gradle file to import Keyple components into your project:&lt;/p>
&lt;pre>&lt;code class="language-java">repositories {
//to import snapshots
maven {url 'https://oss.sonatype.org/content/repositories/snapshots' }
//to import releases
//maven { url 'https://oss.sonatype.org/content/repositories/releases' }
}
dependencies {
//Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core
implementation group: 'org.eclipse.keyple', name: 'keyple-java-core', version: '+'
//Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso
implementation group: 'org.eclipse.keyple', name: 'keyple-java-calypso', version: '+'
//Import PCSC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc
implementation group: 'org.eclipse.keyple', name: 'keyple-java-plugin-pcsc', version: '+'
}
&lt;/code>&lt;/pre>
&lt;p>Add the following statements to your build.gradle file to import Logger components into your project:&lt;/p>
&lt;pre>&lt;code class="language-java">dependencies {
implementation &amp;quot;org.slf4j:slf4j-simple:1.7.25&amp;quot;
implementation &amp;quot;org.slf4j:slf4j-ext:1.7.25&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>Copy the source code below in a new Java Class named Demo_CalypsoTestKit_App2_Pcsc:&lt;/p>
&lt;pre>&lt;code class="language-java">/********************************************************************************
* Copyright (c) Calypso Networks Association 2020 https://www.calypsonet-asso.org/
*
* See the NOTICE file(s) distributed with this work for additional information regarding copyright
* ownership.
*
* This program and the accompanying materials are made available under the terms of the Eclipse
* Public License 2.0 which is available at http://www.eclipse.org/legal/epl-2.0
*
* SPDX-License-Identifier: EPL-2.0
********************************************************************************/
import org.eclipse.keyple.calypso.command.po.parser.ReadDataStructure;
import org.eclipse.keyple.calypso.command.po.parser.ReadRecordsRespPars;
import org.eclipse.keyple.calypso.command.sam.SamRevision;
import org.eclipse.keyple.calypso.transaction.*;
import org.eclipse.keyple.core.selection.*;
import org.eclipse.keyple.core.seproxy.*;
import org.eclipse.keyple.core.seproxy.exception.KeypleBaseException;
import org.eclipse.keyple.core.seproxy.exception.KeypleReaderException;
import org.eclipse.keyple.core.seproxy.exception.NoStackTraceThrowable;
import org.eclipse.keyple.core.seproxy.protocol.SeCommonProtocols;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.plugin.pcsc.PcscPlugin;
import org.eclipse.keyple.plugin.pcsc.PcscPluginFactory;
import org.eclipse.keyple.plugin.pcsc.PcscProtocolSetting;
import org.eclipse.keyple.plugin.pcsc.PcscReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Demo_CalypsoTestKit_App2_Pcsc {
private static final Logger logger =
LoggerFactory.getLogger(Demo_CalypsoTestKit_App2_Pcsc.class);
/* Plugin name */
private final static String PLUGIN_NAME = &amp;quot;PcscPlugin&amp;quot;;
/* PO Reader name */
private final static String PO_READER_NAME = &amp;quot;ASK LoGO 0&amp;quot;;
/* SAM Reader name */
private final static String SAM_READER_NAME = &amp;quot;Identive CLOUD 2700 R Smart Card Reader 0&amp;quot;;
/* AID: Keyple test kit profile 1, Application 2 */
private final static String AID = &amp;quot;315449432E49434131&amp;quot;;
private final static byte RECORD_NUMBER_1 = 1;
private final static byte SFI_EnvironmentAndHolder = (byte) 0x07;
public static void main(String[] args) throws KeypleBaseException, NoStackTraceThrowable {
/* Get the instance of the SeProxyService (Singleton pattern) */
SeProxyService seProxyService = SeProxyService.getInstance();
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= Configuration of the PO &amp;amp; SAM Readers =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
/* Assign PcscPlugin to the SeProxyService */
seProxyService.registerPlugin(new PcscPluginFactory());
/* Get the PcscPlugin */
ReaderPlugin plugin = seProxyService.getPlugin(PcscPlugin.PLUGIN_NAME);
/* Get the PO reader */
SeReader poReader = plugin.getReader(PO_READER_NAME);
/* Sets the PO reader parameters for contactless secure elements */
setContactlessSettings(poReader);
/* Get a SAM reader */
SeReader samReader = plugin.getReader(SAM_READER_NAME);
/* Sets the reader parameters for contacts secure elements */
setContactsSettings(samReader);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= Opening logical channel with the SAM =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
/*
* Open logical channel for the SAM inserted in the reader
* (We expect the right is inserted)
*/
SamResource samResource = checkSamAndOpenChannel(samReader);
/* Check if the readers exists */
if (poReader == null || samResource == null) {
throw new IllegalStateException(&amp;quot;Bad PO or SAM reader setup&amp;quot;);
}
logger.info(&amp;quot;======= Secure reading of Environment and Holder file &amp;amp; Po Authentication =======&amp;quot;);
logger.info(&amp;quot;= PO Reader NAME = {}&amp;quot;, poReader.getName());
logger.info(&amp;quot;= SAM Reader NAME = {}&amp;quot;, samResource.getSeReader().getName());
/* Check if a PO is present in the reader */
if (poReader.isSePresent()) {
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= Start of the Calypso PO processing. =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= 1st PO exchange =&amp;quot;);
logger.info(
&amp;quot;= AID based selection =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
/*
* Prepare a Calypso PO selection
*/
SeSelection seSelection = new SeSelection();
/*
* Setting of an AID based selection of a Calypso REV3 PO
*
* Select the first application matching the selection AID whatever the SE communication protocol
* Keep the logical channel open after the selection
*
* Calypso PO selection: configures a PoSelectionRequest with all the desired attributes to
* make the selection and read additional information afterwards
*/
PoSelectionRequest poSelectionRequest = new PoSelectionRequest(
new PoSelector( //the selector to target a particular SE
SeCommonProtocols.PROTOCOL_ISO14443_4, // the SE communication protocol
null, // the ATR filter
new PoSelector.PoAidSelector( // the AID selection data
new SeSelector.AidSelector.IsoAid(AID), // the application identifier
PoSelector.InvalidatedPo.REJECT), // an enum value to indicate if an invalidated PO should be accepted or not
&amp;quot;AID: &amp;quot;+ AID), // information string (to be printed in logs)
ChannelState.KEEP_OPEN); // tell if the channel is to be closed or not after the command
/*
* Add the selection case to the current selection (we could have added other cases
* here)
*/
seSelection.prepareSelection(poSelectionRequest);
/*
* Actual PO communication: operate through a single request the Calypso PO selection
* and the file read
*/
SelectionsResult selectionsResult = seSelection.processExplicitSelection(poReader);
if (selectionsResult.hasActiveSelection()) {
MatchingSelection matchingSelection = selectionsResult.getActiveSelection();
CalypsoPo calypsoPo = (CalypsoPo) matchingSelection.getMatchingSe();
logger.info(&amp;quot;The selection of the PO has succeeded.&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= 2nd PO exchange =&amp;quot;);
logger.info(
&amp;quot;= Open a secure session =&amp;quot;);
logger.info(
&amp;quot;= Reading of Environment and Holder file (SFI=07h) =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
PoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo),
samResource, new SecuritySettings());
/*
* Prepare the reading order and keep the associated parser for later use once the
* transaction has been processed.
*/
int readEnvironmentAndHolderParserIndex = poTransaction.prepareReadRecordsCmd(
SFI_EnvironmentAndHolder, // the sfi top select
ReadDataStructure.SINGLE_RECORD_DATA, // read mode enum to indicate a SINGLE, MULTIPLE or COUNTER read
RECORD_NUMBER_1, // the record number to read (or first record to read in case of several records)
String.format( // extra information included in the logs (can be null or empty)
&amp;quot;EventLog (SFI=%02X, recnbr=%d))&amp;quot;,
SFI_EnvironmentAndHolder,
RECORD_NUMBER_1));
/*
* Open Session for the debit key
*/
boolean poProcessStatus = poTransaction.processOpening(
PoTransaction.ModificationMode.ATOMIC,
PoTransaction.SessionAccessLevel.SESSION_LVL_DEBIT, (byte) 0, (byte) 0);
if (!poProcessStatus) {
throw new IllegalStateException(&amp;quot;processingOpening failure.&amp;quot;);
}
if (!poTransaction.wasRatified()) {
logger.info(
&amp;quot;=================== Previous Secure Session was not ratified ====================&amp;quot;);
}
/*
* Retrieve the data read from the parser updated during the transaction process
*/
byte EnvironmentAndHolderLog[] = (((ReadRecordsRespPars) poTransaction
.getResponseParser(readEnvironmentAndHolderParserIndex)).getRecords())
.get((int) RECORD_NUMBER_1);
/* Log the result */
logger.info(&amp;quot;Environment And Holder file data: {}&amp;quot;, ByteArrayUtil.toHex(EnvironmentAndHolderLog));
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= 3th PO exchange =&amp;quot;);
logger.info(
&amp;quot;= Close the secure session =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
/*
* Close the Secure Session.
* A ratification command will be sent (CONTACTLESS_MODE).
*/
poProcessStatus = poTransaction.processClosing(ChannelState.CLOSE_AFTER);
if (!poProcessStatus) {
throw new IllegalStateException(&amp;quot;processClosing failure.&amp;quot;);
}
logger.info(
&amp;quot;=================================================================================&amp;quot;);
logger.info(
&amp;quot;= Successful mutual authentication =&amp;quot;);
logger.info(
&amp;quot;= End of the Calypso PO processing =&amp;quot;);
logger.info(
&amp;quot;=================================================================================&amp;quot;);
} else {
logger.error(&amp;quot;The selection of the PO has failed.&amp;quot;);
}
} else {
logger.error(&amp;quot;No PO were detected.&amp;quot;);
}
System.exit(0);
}
/**
* Sets the reader parameters for contactless secure elements
*
* @param reader the reader to configure
* @throws KeypleBaseException in case of an error while settings the parameters
*/
private static void setContactlessSettings(SeReader reader) throws KeypleBaseException {
/* Enable logging */
reader.setParameter(PcscReader.SETTING_KEY_LOGGING, &amp;quot;true&amp;quot;);
/* Contactless SE works with T1 protocol */
reader.setParameter(PcscReader.SETTING_KEY_PROTOCOL, PcscReader.SETTING_PROTOCOL_T1);
/*
* PC/SC card access mode:
* The PO reader is set to EXCLUSIVE mode to avoid side effects during the selection step
* that may result in session failures.
*/
reader.setParameter(PcscReader.SETTING_KEY_MODE, PcscReader.SETTING_MODE_EXCLUSIVE);
/* Set the PO reader protocol flag */
reader.addSeProtocolSetting(
SeCommonProtocols.PROTOCOL_ISO14443_4,
PcscProtocolSetting.PCSC_PROTOCOL_SETTING.get(SeCommonProtocols.PROTOCOL_ISO14443_4));
}
/**
* Sets the reader parameters for contacts secure elements
*
* @param reader the reader to configure
* @throws KeypleBaseException in case of an error while settings the parameters
*/
private static void setContactsSettings(SeReader reader) throws KeypleBaseException {
/* Enable logging */
reader.setParameter(PcscReader.SETTING_KEY_LOGGING, &amp;quot;true&amp;quot;);
/* Contactless SE works with T0 protocol */
reader.setParameter(PcscReader.SETTING_KEY_PROTOCOL, PcscReader.SETTING_PROTOCOL_T0);
/*
* PC/SC card access mode:
* The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the
* limited time between two consecutive exchanges granted by Windows.
*/
reader.setParameter(PcscReader.SETTING_KEY_MODE, PcscReader.SETTING_MODE_SHARED);
/* Set the SAM reader protocol flag */
reader.addSeProtocolSetting(
SeCommonProtocols.PROTOCOL_ISO7816_3,
PcscProtocolSetting.PCSC_PROTOCOL_SETTING.get(SeCommonProtocols.PROTOCOL_ISO7816_3));
}
/**
* Check SAM presence and consistency and return a SamResource when everything is correct.
*
* Throw an exception if the expected SAM is not available
*
* @param samReader the SAM reader
*/
private static SamResource checkSamAndOpenChannel(SeReader samReader) {
/*
* Check the availability of the SAM doing a ATR based selection,
* open its physical and logical channels,
* keep it open
*/
SeSelection samSelection = new SeSelection();
SamSelector samSelector = new SamSelector(SamRevision.C1, &amp;quot;.*&amp;quot;, &amp;quot;Selection SAM C1&amp;quot;);
/* Prepare selector, ignore AbstractMatchingSe here */
samSelection.prepareSelection(new SamSelectionRequest(samSelector, ChannelState.KEEP_OPEN));
CalypsoSam calypsoSam;
try {
calypsoSam = (CalypsoSam) samSelection.processExplicitSelection(samReader)
.getActiveSelection().getMatchingSe();
if (!calypsoSam.isSelected()) {
throw new IllegalStateException(&amp;quot;Unable to open a logical channel for SAM!&amp;quot;);
}
} catch (KeypleReaderException e) {
throw new IllegalStateException(&amp;quot;SAM Reader exception: &amp;quot; + e.getMessage());
}
return new SamResource(samReader, calypsoSam);
}
}
&lt;/code>&lt;/pre>
&lt;p>Copy the properties file below in a new properties file named simplelogger.properties in resources. The application log output format is configurable in this properties files.&lt;/p>
&lt;pre>&lt;code class="language-properties"># SLF4J's SimpleLogger configuration file
# Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err.
# Default logging detail level for all instances of SimpleLogger.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, defaults to &amp;quot;info&amp;quot;.
org.slf4j.simpleLogger.defaultLogLevel=trace
# Logging detail level for a SimpleLogger instance named &amp;quot;xxxxx&amp;quot;.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, the default logging detail level is used.
#org.slf4j.simpleLogger.log.xxxxx=
# Set to true if you want the current date and time to be included in output messages.
# Default is false, and will output the number of milliseconds elapsed since startup.
org.slf4j.simpleLogger.showDateTime=true
# The date and time format to be used in the output messages.
# The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat.
# If the format is not specified or is invalid, the default format is used.
# The default format is yyyy-MM-dd HH:mm:ss:SSS Z.
org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS]
# Set to true if you want to output the current thread name.
# Defaults to true.
org.slf4j.simpleLogger.showThreadName=true
# Set to true if you want the Logger instance name to be included in output messages.
# Defaults to true.
org.slf4j.simpleLogger.showLogName=false
# Set to true if you want the last component of the name to be included in output messages.
# Defaults to false.
org.slf4j.simpleLogger.showShortLogName=true
org.slf4j.simpleLogger.levelInBrackets=true
&lt;/code>&lt;/pre>
&lt;h2 id="run">Run&lt;/h2>
&lt;p>Connect your PO and SAM readers.&lt;/p>
&lt;p>Put the SAM in the SAM reader.&lt;/p>
&lt;p>Place the PO on the PO reader.&lt;/p>
&lt;p>Configure the PO and SAM readers you use in the java file (you have to respect the case for the reader name) :&lt;/p>
&lt;pre>&lt;code class="language-java"> /* PO Reader name */
private final static String PO_READER_NAME = &amp;quot;XXX&amp;quot;;
/* SAM Reader name */
private final static String SAM_READER_NAME = &amp;quot;XXX&amp;quot;;
&lt;/code>&lt;/pre>
&lt;p>If you don’t know the reader name, run the application in debug mode and get the reader name in plugin variable returned by:&lt;/p>
&lt;blockquote>
&lt;p>seProxyService.getPlugin(PLUGIN_NAME) methode: plugin -&amp;gt; readers -&amp;gt; X -&amp;gt; terminal -&amp;gt; name .&lt;/p>
&lt;/blockquote>
&lt;p>Run the application.&lt;/p>
&lt;p>Note: All project dependencies, including Keyple components, are downloaded during the first run, which can take several minutes.&lt;/p></description></item><item><title>(WIP)Developer guide - Develop a ticketing application</title><link>/keyple-website/docs/developer-guides/developer-guide-ticketing-app/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/developer-guides/developer-guide-ticketing-app/</guid><description>&lt;p>This guide is intended for developers of ticketing applications.
It shows, based on sample code, the different operations that can constitute a Calypso card-based transaction application.
In this guide the card readers are PC/SC type but the principles would be the same with other types of readers.&lt;/p>
&lt;h2 id="imports">Imports&lt;/h2>
&lt;p>The application imports the keyple-core (base), keyple-plugin-pcsc (PC/SC reader access) and keyple-calyspo (Calypso card operations) modules.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-core:$keyple_version&amp;quot;
implementation &amp;quot;org.eclipse.keyple:keyple-java-calypso:$keyple_version&amp;quot;
implementation &amp;quot;org.eclipse.keyple:keyple-java-plugin-pcsc:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="code-toggle-test">Code toggle test&lt;/h2>
&lt;section class="project-tab" id="tabs">
&lt;div class="container" style="margin: 0; padding: 0">
&lt;div class="flex-row">
&lt;div>
&lt;nav>
&lt;div class="nav nav-tabs nav-fill" id="nav-tab" role="tablist">
&lt;a aria-controls="nav-java" aria-selected="true" class="nav-item nav-link active"
data-toggle="tab" href="#nav-java" id="nav-java-tab" role="tab">
JAVA
&lt;/a>
&lt;a aria-controls="nav-kotlin" aria-selected="false" class="nav-item nav-link" data-toggle="tab"
href="#nav-kotlin" id="nav-kotlin-tab" role="tab">
KOTLIN
&lt;/a>
&lt;a aria-controls="nav-cpp" aria-selected="false" class="nav-item nav-link" data-toggle="tab"
href="#nav-cpp" id="nav-cpp-tab" role="tab">
C++
&lt;/a>
&lt;/div>
&lt;/nav>
&lt;div class="tab-content" id="nav-tabContent">
&lt;div aria-labelledby="nav-java-tab" class="tab-pane fade show active" id="nav-java" role="tabpanel">
&lt;div>&lt;div class="highlight">&lt;div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">SelectionsResult selectionsResult &lt;span style="color:#f92672">=&lt;/span> seSelection&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">processExplicitSelection&lt;/span>&lt;span style="color:#f92672">(&lt;/span>reader&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>selectionsResult&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">hasActiveSelection&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
MatchingSe matchingSe &lt;span style="color:#f92672">=&lt;/span> selectionsResult&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getActiveMatchingSe&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/div>
&lt;/div>
&lt;div aria-labelledby="nav-kotlin-tab" class="tab-pane fade" id="nav-kotlin" role="tabpanel">
&lt;div>&lt;div class="highlight">&lt;div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kt" data-lang="kt">&lt;span style="color:#66d9ef">val&lt;/span> selectionsResult = seSelection.processExplicitSelection(reader)
&lt;span style="color:#66d9ef">if&lt;/span> (selectionsResult.hasActiveSelection()) {
&lt;span style="color:#66d9ef">val&lt;/span> matchingSe = selectionsResult.activeMatchingSe
}&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/div>
&lt;/div>
&lt;div aria-labelledby="nav-cpp-tab" class="tab-pane fade" id="nav-cpp" role="tabpanel">
&lt;div>&lt;div class="highlight">&lt;div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">if&lt;/span> (selectionResult&lt;span style="color:#f92672">-&amp;gt;&lt;/span>hasActiveSelection()) {
std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>MatchingSelection&lt;span style="color:#f92672">&amp;gt;&lt;/span> matchingSelection &lt;span style="color:#f92672">=&lt;/span>
selectionResult&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getActiveSelection();
std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>CalypsoPo&lt;span style="color:#f92672">&amp;gt;&lt;/span> calypsoPo &lt;span style="color:#f92672">=&lt;/span>
std&lt;span style="color:#f92672">::&lt;/span>dynamic_pointer_cast&lt;span style="color:#f92672">&amp;lt;&lt;/span>CalypsoPo&lt;span style="color:#f92672">&amp;gt;&lt;/span>(
matchingSelection&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getMatchingSe());
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/section>
&lt;h2 id="connect-a-plugin">Connect a plugin&lt;/h2>
&lt;h2 id="configuring-a-plugin">Configuring a plugin&lt;/h2>
&lt;h2 id="retrieve-a-reader">Retrieve a reader&lt;/h2>
&lt;h2 id="subscribe-to-the-events-of-a-reader">Subscribe to the events of a reader&lt;/h2>
&lt;h2 id="receive-a-card-event">Receive a card event&lt;/h2>
&lt;h2 id="make-an-explicit-selection">Make an explicit selection&lt;/h2>
&lt;h2 id="make-an-implicit-selection">Make an implicit selection&lt;/h2>
&lt;h2 id="preparing-commands">Preparing commands&lt;/h2>
&lt;h2 id="sending-commands">Sending commands&lt;/h2>
&lt;h2 id="retrieve-responses">Retrieve responses&lt;/h2>
&lt;h2 id="open-a-calypso-session">Open a calypso session&lt;/h2>
&lt;h2 id="close-a-calypso-session">Close a calypso session&lt;/h2></description></item><item><title>Keyple ‘Core’ – Architecture</title><link>/keyple-website/docs/architecture-keyplecore/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/architecture-keyplecore/</guid><description>&lt;p>This high-level API is convenient for developers implementing smart card processing application for terminal interfaced with smart card readers.&lt;/p>
&lt;h2 id="packages--features">Packages &amp;amp; features&lt;/h2>
&lt;p>The Keyple Core User API is a tool to manage readers, and to select “generic” Secure Elements.&lt;/p>
&lt;table>
&lt;tr>
&lt;td colspan="2">&lt;b>Features&lt;/b>&lt;/td>
&lt;td>&lt;b>Packages&lt;/b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td rowspan="3">SE reader management&lt;/td>
&lt;td>Secure Element reader access&lt;/td>
&lt;td>org.eclipse.keyple.core.&lt;b>seproxy&lt;b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Notifications of:
&lt;li>reader plug/unplug,&lt;/li>
&lt;li>SE insertion/remove&lt;/li>
Definition of automatic selection request in case of SE insertion on an Observable Reader.&lt;/td>
&lt;td>org.eclipse.keyple.core.seproxy.&lt;b>event&lt;b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Communication protocols filters (setting for contactless/contacts SE Reader)&lt;/td>
&lt;td>org.eclipse.keyple.core.seproxy.&lt;b>protocol&lt;b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SE selection&lt;/td>
&lt;td>Generic selection of a Secure Element&lt;/td>
&lt;td>org.eclipse.keyple.core.&lt;b>selection&lt;b>&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h2 id="secure-element-transaction-sequence--setting--selection">Secure Element transaction sequence – setting &amp;amp; selection&lt;/h2>
&lt;p>A Secure Element transaction starts with the setting of plugins in order to choose the reader to communicate with SE.&lt;/p>
&lt;p>Using a SE reader, depending on its capabilities, there can be two ways to select a SE through it:&lt;/p>
&lt;ul>
&lt;li>Either the processing of an “explicit selection”: if a SE is present in the reader, then the terminal directly operates a SE selection request through the reader.&lt;/li>
&lt;li>Otherwise if the reader is “observable”, the operating of a “default selection”: in this case a default selection request is defined on the reader, the terminal observes the reader, and wait to be notified by the reader about a SE insertion and selection.&lt;/li>
&lt;/ul>
&lt;p>At the end the terminal gets a selected SE, it can follow by operating APDU commands with the selected SE until the communication channel is kept open.&lt;/p>
&lt;p>&lt;img src="../../img/KeypleCore-0-SE_SelectionScenarii.png" alt="SE Selection Scenarii scheme" title="SE Selection Scenarii">&lt;/p>
&lt;p>Then a Keyple Core extension could be used to operates APDU commands with the selected SE solution.&lt;/p>
&lt;blockquote>
&lt;p>The Keyple Calypso extension provides a high-level API to defined ticketing processing involving Calypso cards, cf.:
&lt;a href="https://github.com/eclipse/keyple-java/blob/master/docs/KeypleCalypso_UserGuide.adoc" target="_blank" rel="noopener">“Keyple Calypso User Guide”&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;h2 id="secure-element-proxy-service-api--readers-management">Secure Element Proxy Service API – readers management&lt;/h2>
&lt;p>Using the Keyple Core, Secure Element Readers (SeReader) are managed through plugins (ReaderPlugin).&lt;/p>
&lt;p>The active plugins are registered to the SE Proxy Service (the singleton SeProxyService).&lt;/p>
&lt;ul>
&lt;li>Each plugin is registered through a unique name to the SE Proxy Service.&lt;/li>
&lt;li>Each reader of a plugin is also defined with a unique name inside the plugin.&lt;/li>
&lt;/ul>
&lt;h3 id="plugin-setting">Plugin setting&lt;/h3>
&lt;p>To secure the usage of the SE Proxy API for the development of terminal applications, the internal implementation of plugins (classes SpecificPluginImpl &amp;amp; SpecificReaderImpl) is hidden.&lt;/p>
&lt;ul>
&lt;li>For a specific plugin, only the plugin &amp;amp; reader interfaces (SpecificPlugin &amp;amp; SpecificReader) and the factory (class SpecificPluginFactory) are public.&lt;/li>
&lt;li>The factory of a plugin is set to register a specific plugin to the SE Proxy Service.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../img/KeypleCore-1-SE_Proxy-PluginSetting.png" alt="SE Proxy - Plugin Setting scheme" title="SE Proxy - Plugin Setting">&lt;/p>
&lt;p>Most of plugins of local readers of Keyple are defined as singleton with a unique instance (e.g.: PC/SC, Android NFC, Android OMAPI, most of embedded readers).&lt;/p>
&lt;p>For the Remote SE plugin defined to manage remote readers, specific plugin instances are created for each communication interfaces.&lt;/p>
&lt;h3 id="se-readers-access">SE readers’ access&lt;/h3>
&lt;p>The SE Proxy Service allows to get all the list of the active plugins. A specific plugin could also be directly recovered through its name.&lt;/p>
&lt;p>In the same way, a plugin can provide the list of all the plugged readers.&lt;/p>
&lt;p>&lt;img src="../../img/KeypleCore-2-SE_Proxy-ReaderAccess.png" alt="SE Proxy - Reader Access scheme" title="SE Proxy - Reader Access">&lt;/p>
&lt;p>Depending on the native reader technology, some specific parameters could be defined at the plugin or reader level.&lt;/p>
&lt;p>For a classic plugin, the number of readers is determinate, all the plugged readers of the plugin are directly available for the SE Proxy Service.&lt;/p>
&lt;h4 id="support-of-reader-farm-or-hsm">Support of reader farm or HSM&lt;/h4>
&lt;p>For systems based on a centralized security, in order to manage multiple remote terminal in parallel, central servers could requires to interface a huge number (several hundreds or thousands) of SE through a farm of readers or HSM (Hardware Security Module: an electronic board able to emulate multiple SE).&lt;/p>
&lt;ul>
&lt;li>The multitude of embedded SE could be divided in different groups of profiles.&lt;/li>
&lt;li>An HSM is often shared between several services, so the full set of readers isn&amp;rsquo;t directly available for a service, a service has to request the allocation of a reader from a specific group.&lt;/li>
&lt;/ul>
&lt;p>The SE Proxy Service could support reader farm or HSM though plugins managing &amp;ldquo;pool&amp;rdquo; of readers (ReaderPoolPlugin).&lt;/p>
&lt;ul>
&lt;li>At the initialization, the list of reader is empty. The list is be filled depending on the reader allocations requested.&lt;/li>
&lt;li>When not more required, a reader could be released from the pool.&lt;/li>
&lt;/ul>
&lt;p>All plugins have to implement the interface ReaderPlugin and SeReader. A plugin managing a pool of reader should implement in addition the interface ReaderPoolPlugin.&lt;/p>
&lt;h4 id="se-presence-check--explicit-selection-transaction">SE presence check &amp;amp; “explicit selection transaction”&lt;/h4>
&lt;p>A SE reader has the capability to check is a SE is present or not.&lt;/p>
&lt;blockquote>
&lt;p>For SE terminal processing for which the presence of a SE in a reader is &amp;ldquo;static' during a transaction, the transaction starts in general with the verification of the SE presence. If the SE is present, the transaction can continue with the selection of the SE. We call this kind of transaction: an &amp;ldquo;explicit selection transaction&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;h3 id="plugin--reader-events">Plugin &amp;amp; Reader events&lt;/h3>
&lt;p>For some SE terminal, the processing is dynamically driven by the insertion/remove of a SE in a reader, or by the plug/unplug of a reader.&lt;/p>
&lt;p>E.g., in transportation, the ticketing transaction of access control gates is often started when a contactless card is detected in the field of the reader. For that, in Keyple, a SE reader or a plugin has to be observable.&lt;/p>
&lt;p>&lt;img src="../../img/KeypleCore-3-SE_Proxy-ObserverPattern.png" alt="SE Proxy - Observer Pattern scheme" title="SE Proxy - Observer Pattern">&lt;/p>
&lt;p>A plugin could be optionally observable (by implementing ObservablePlugin).&lt;/p>
&lt;ul>
&lt;li>In this case a terminal application could observe the plugin (by implementing PluginObserver) in order to be notified (PluginEvent) when a new reader is plugged to the plugin, or when a referenced reader is unplugged.&lt;/li>
&lt;li>To receive the notification of a specific plugin, the plugin observer should first be added to the observer list of the observable plugin.&lt;/li>
&lt;/ul>
&lt;p>Depending on the capability of the plugin, a reader could be optionally observable (by implementing ObservableReader).&lt;/p>
&lt;ul>
&lt;li>A terminal application could observe the plugin (by implementing ReaderObserver) in order to be notified (ReaderEvent) when a SE is inserted or removed from a specific.&lt;/li>
&lt;li>The reader observer should be added to the observer list to receive the notifications the observable reader.&lt;/li>
&lt;/ul>
&lt;p>By default, an observable reader notifies only the insertion or the remove of a SE.&lt;/p>
&lt;h4 id="plugin-observability-activation">Plugin observability activation&lt;/h4>
&lt;p>An observable plugin automatically starts to observe plugin events when at least one plugin observer is registered and stops the listening when the last plugin observer is removed.&lt;/p>
&lt;h4 id="automatic-selection--default-selection-transaction">Automatic selection &amp;amp; “default selection transaction”&lt;/h4>
&lt;p>On an observable reader, there is in addition the possibility to define a &amp;ldquo;default selection operation&amp;rdquo;: in this case, when a SE is inserted, the observable reader tries automatically to select the inserted SE using the defined default setting.&lt;/p>
&lt;ul>
&lt;li>If the inserted SE is successfully selected, then the observable reader notifies that &amp;ldquo;an inserted SE has matched the default selection&amp;rdquo; and provides the corresponding response.&lt;/li>
&lt;li>Otherwise if the observable reader failed to select the inserted SE, it could just notify that a SE has been inserted.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>For SE terminal for which the processing is &amp;ldquo;dynamically&amp;rdquo; driven by the presence of a SE in a reader, the transaction starts in general with the detection of the insertion of a SE and its automatic selection. The reader observer is then notified to analyze the response of the selected SE, and to continue the transaction with the SE. We call this kind of transaction: a &amp;ldquo;default selection transaction&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="../../img/KeypleCore-4-SE_Proxy-SE_Listening.png" alt="SE Proxy - SE Listening scheme" title="SE Proxy - SE Listening">&lt;/p>
&lt;h4 id="reader-notification-modes">Reader notification modes&lt;/h4>
&lt;p>If no default selection is defined, an observable reader notifies its observers for “SE insertion” (whatever the SE detected) or “SE removed” events.
A default selection could be defined for the “always” or the &amp;ldquo;matched only” notification mode.&lt;/p>
&lt;ul>
&lt;li>In the always mode, if the inserted matches the default selection, the observers are notified about a “SE matched” event, otherwise an “SE insertion” event is notified.&lt;/li>
&lt;li>In case of &amp;ldquo;matched only” mode, the observable reader doesn’t notify SE insertion event. The reader observer will be notified only if a default selection succeed on the observable reader; this configuration allows the reader observer to skip the processing of wrong SE insertions.&lt;/li>
&lt;/ul>
&lt;h4 id="reader-observability-activation-polling-mode--se-removal-procedure">Reader observability activation, “polling mode” &amp;amp; “SE removal procedure”&lt;/h4>
&lt;p>For an observable reader, the listening of reader event requires also the registration of at least one reader observer.&lt;/p>
&lt;p>An observable reader could switch between four internal states: “Wait for start detection”, “Wait for SE insertion”, “Wait for SE processing”, “Wait for SE removal”.&lt;/p>
&lt;ul>
&lt;li>At the wait for start detection, the observable reader doesn’t notify any event.&lt;/li>
&lt;li>The start of the SE detection by an observable reader need to be explicitly requested by an observer by setting a “polling mode” either through a ‘startSeDetection’ or a ‘setDefaultSelectionRequest’ commands. The SE detection could be started for polling mode defined either in “single shot” or “repeating” mode.
&lt;ul>
&lt;li>In single shot mode, the observable reader stops the detection after the SE removal (back to the wait for start detection).&lt;/li>
&lt;li>In repeating mode, after the SE removal, the observable reader restart to detect another SE (back to the wait for SE insertion).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Wait for SE insertion, if a SE is inserted or selected, the registered reader observers are notified by the observable reader according to the defined notification mode. The observable reader switches to the wait for SE processing.&lt;/li>
&lt;li>During the SE processing by the observers, the observable reader waits that an observer acknowledges the end of the SE processing.&lt;/li>
&lt;li>There are two waits to ends the processing of an observed SE:
&lt;ul>
&lt;li>Either an observer directly could stop the listening of the observable reader (‘stopSeDetection’ command). The observable reader switches to the wait for start detection, and the observers are immediately notified about the SE remove.&lt;/li>
&lt;li>Otherwise, the observers could wait for a clean remove of the SE from the observable reader; it’s the SE removal sequence:
&lt;ul>
&lt;li>When the main reader observer has finished the processing of the SE, it could request the observable reader to wait for the remove of the SE (‘notifySeProcessed’ command).&lt;/li>
&lt;li>Finally, the reader observers could be notified when the SE is effectively removed.&lt;/li>
&lt;li>If the SE insertion listening started in the &amp;ldquo;repeating polling mode&amp;rdquo;, then when the SE is removed, the observable reader automatically starts again the listening of a new SE insertion; otherwise a new explicit request to start the SE listening is required to restart the listening.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="secure-element-selection-api">Secure Element Selection API&lt;/h2>
&lt;h3 id="selection-parameters-communication-protocol-atr-aid">Selection parameters (Communication protocol, ATR, AID)&lt;/h3>
&lt;p>To select a Secure Element, a SE Selector has to be defined, based on one to three parameters.&lt;/p>
&lt;ul>
&lt;li>A SE selection could be defined for a specific communication protocol.&lt;/li>
&lt;li>A SE could be filtered for an ATR (Answer To Reset) matching a specific regular expression.&lt;/li>
&lt;li>A specific application of a SE could be selected by setting its AID (Application IDentifier).&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../img/KeypleCore-5-SE_Proxy-SE_Selector.png" alt="SE Proxy - SE Selector scheme" title="SE Proxy - SE Selector">&lt;/p>
&lt;h3 id="selection-transaction">Selection transaction&lt;/h3>
&lt;p>To operate a transaction with a SE, it should be firstly selected. The aim of the SE selection API is to get a SE resource: a set of a reader with a selected SE.&lt;/p>
&lt;p>A SE Selection is managed in two steps:&lt;/p>
&lt;ul>
&lt;li>first the “preparations” of selection request based on SE selector,&lt;/li>
&lt;li>next the “processing” of the selection requests.&lt;/li>
&lt;/ul>
&lt;p>In order to manage multiple kinds of SE, several selection requests could be prepared with different selectors.&lt;/p>
&lt;p>Depending on the setting of the reader, the processing of the selection could be operated in two different ways:&lt;/p>
&lt;ul>
&lt;li>either in a “explicit” way after the checking of the SE presence,&lt;/li>
&lt;li>or in a ”default” way for an observable reader detecting the insertion of a SE.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/generic/pc/UseCase1_ExplicitSelectionAid/src/main/java/org/eclipse/keyple/example/generic/pc/usecase1/ExplicitSelectionAid_Pcsc.java" target="_blank" rel="noopener">“Generic Use Case 1 / Explicit AID Selection”&lt;/a> example&lt;br>
cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/generic/pc/UseCase2_DefaultSelectionNotification/src/main/java/org/eclipse/keyple/example/generic/pc/usecase2/DefaultSelectionNotification_Pcsc.java" target="_blank" rel="noopener">“Generic Use Case 2 / Default Selection Notification”&lt;/a> example&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="../../img/KeypleCore-6-SE_Proxy-SE_Selection.png" alt="SE Proxy - SE Selection scheme" title="SE Proxy - SE Selection">&lt;/p>
&lt;p>In case a SE Selection is prepared with a channel control mode defined as “keep open”, then the different prepared selectors are operated with the presented SE, but the processing of the selection stops when a selector matches the SE.&lt;/p>
&lt;ul>
&lt;li>The result of the SE selection could be a single ‘matching SE’: this SE is kept as selected in the reader. It’s possible to directly operate command with the SE.&lt;/li>
&lt;/ul>
&lt;p>But if a SE selection has been defined with a channel control mode at “close after”, in this case all the prepared SE selectors are operated whatever the matching result.&lt;/p>
&lt;ul>
&lt;li>After each selector processing, if a selector has matched, the logical channel with the SE is closed (the SE is no more selected).&lt;/li>
&lt;li>If several applications of the presented SE have matched the selectors: the result of the processing of SE selections is a list matching SE, but all of them are deselected. To continue the SE processing, the terminal application has to choose one matching SE, and to select it again but in “keep open” channel control mode.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/generic/pc/UseCase3_GroupedMultiSelection/src/main/java/org/eclipse/keyple/example/generic/pc/usecase3/GroupedMultiSelection_Pcsc.java" target="_blank" rel="noopener">“Generic Use Case 3 / Grouped Multi-Selection”&lt;/a> example&lt;/p>
&lt;/blockquote>
&lt;p>After the selection of a SE, using a SE resource, the terminal can continue by operating a specific transaction with the corresponding SE.&lt;/p>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/generic/pc/UseCase4_SequentialMultiSelection/src/main/java/org/eclipse/keyple/example/generic/pc/usecase4/SequentialMultiSelection_Pcsc.java" target="_blank" rel="noopener">“Generic Use Case 4 / Sequential Multi-Selection”&lt;/a> example&lt;/p>
&lt;/blockquote></description></item><item><title>(WIP)Developer guide - Develop a Plugin</title><link>/keyple-website/docs/developer-guide-plugin/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/developer-guide-plugin/</guid><description>&lt;p>This guide will provide nescessary steps to develop a Keyple plugin for a device. In order to flatten the learning curve, we&amp;rsquo;ll
illustrate the creation processus using the implementation of the Android NFC Plugin and OMAPI plugins.
This plugins can be consulted with the keyple-java/android repository.&lt;/p>
&lt;h2 id="imports">Imports&lt;/h2>
&lt;p>Your plugin will use be based upon Keyple Core libraries:&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-core:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="implement-keyple-reader">Implement Keyple Reader&lt;/h2>
&lt;p>The basis component of a Keyple plugin is the implementation of an AbstractLocalReader. The AbstractLocalReader implementation will map the native reader&amp;rsquo;s
features of the device to Keyple Reader component allowing to be used within the Keyple suite.&lt;/p>
&lt;p>The &amp;lsquo;local&amp;rsquo; in AbstractLocalReader is used to specify devices physicaly connected to the device.&lt;/p>
&lt;p>Relying on native libraries capacities of the device, implementations to be done are:&lt;/p>
&lt;ul>
&lt;li>checkSePresence()&lt;/li>
&lt;li>getATR()&lt;/li>
&lt;li>openPhysicalChannel()&lt;/li>
&lt;li>closePhysicalChannel()&lt;/li>
&lt;li>isPhysicalChannelOpen()&lt;/li>
&lt;li>ProtocolFlagMatches()&lt;/li>
&lt;li>TransmitApdu&lt;/li>
&lt;/ul>
&lt;p>###Examples&lt;/p>
&lt;h4 id="checksepresence">checkSePresence()&lt;/h4>
&lt;p>Allow Keyple to check if the secure elements is inserted or in the NFC field of the device.&lt;/p>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//nativeReader is an instance of android.se.omapi.Reader
override fun checkSePresence(): Boolean {
return nativeReader.isSecureElementPresent
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//When a SE is presented in the NFC field, we can get a tagproxy object. When the SE is removed,
//this value is reinited. So when it is not null, we can assume the SE is currently in the field.
public override fun checkSePresence(): Boolean {
return tagProxy != null
}
&lt;/code>&lt;/pre>
&lt;h4 id="getatr">getAtr()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//Session is a native object of android.se.omapi package
override fun getATR(): ByteArray? {
return session?.let {
it.atr
}
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//TagProxy is an object mapping android.nfc.tech.TagTechnology. Atr is obtained from data of this object (epending of protocol)
public override fun getATR(): ByteArray? {
val atr = tagProxy?.atr
return if (atr?.isNotEmpty() == true) atr else null
}
&lt;/code>&lt;/pre>
&lt;h4 id="openphysicalchannel">openPhysicalChannel()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">@Throws(KeypleReaderIOException::class)
override fun openPhysicalChannel() {
try {
session = nativeReader.openSession()
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;IOException while opening physical channel.&amp;quot;, e)
}
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">@Throws(KeypleReaderIOException::class)
public override fun openPhysicalChannel() {
if (tagProxy?.isConnected != true) {
try {
tagProxy?.connect()
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;Error while opening physical channel&amp;quot;, e)
}
}
}
&lt;/code>&lt;/pre>
&lt;p>Also, this implementation could be done extending AbstractObservableLocalReader. It provides :&lt;/p>
&lt;ul>
&lt;li>State machine regarding SE event: &amp;lsquo;WAIT_FOR_START_DETECTION&amp;rsquo;, &amp;lsquo;WAIT_FOR_SE_INSERTION&amp;rsquo;&amp;hellip;&lt;/li>
&lt;li>Extended readers features
&lt;ul>
&lt;li>Smart Insertion Reader: Allow to detect SE insertion&lt;/li>
&lt;li>Smart Removal Reader: Allow to detect SE Removal&lt;/li>
&lt;li>Smart Selection Reader: Allow to use native SE selection process&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Keyple Calypso – Architecture</title><link>/keyple-website/docs/architecture-keyplecalypso/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/architecture-keyplecalypso/</guid><description>&lt;h2 id="packages--features">Packages &amp;amp; features&lt;/h2>
&lt;p>The &lt;strong>Keyple Calypso User API is an extension of the Keyple Core User API&lt;/strong> to manage Calypso Portable Object securely using Calypso SAM:&lt;/p>
&lt;ul>
&lt;li>The generic Secure Element selection is enhanced for the &lt;strong>selection of a Calypso PO&lt;/strong>. The FCI response is automatically analyzed in order to identify the revision and the features supported by the Calypso PO. The invalidation status is also checked.&lt;/li>
&lt;li>The selected Calypso PO object allows to automatically initialize a &lt;strong>Calypso PO transaction&lt;/strong>: high level functional commands could be prepared and processed in order to &lt;strong>read or write data in the PO file structure&lt;/strong>, outside or securely inside a &lt;strong>Calypso secure session&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;table>
&lt;tr>
&lt;td colspan="2">&lt;b>Features&lt;/b>&lt;/td>
&lt;td>&lt;b>Packages&lt;/b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td rowspan="2" width="15%">Calypso PO operations&lt;/td>
&lt;td width="50%">Selection of Calypso SE: PO or SAM
PO transaction:
&lt;li>Read / update of data&lt;/li>
&lt;li>PO authentication&lt;/li>&lt;/td>
&lt;td width="35%">org.eclipse.keyple.calypso.&lt;b>transaction&lt;b>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Calypso PO responses data parsing&lt;/td>
&lt;td>org.eclipse.keyple.calypso.&lt;b>command.po.parser&lt;b>&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h2 id="calypso-selection">Calypso Selection&lt;/h2>
&lt;p>The Calypso API to select a Portable object is an extension of the generic Secure Element selection Core API:&lt;/p>
&lt;ul>
&lt;li>A PO AID selection could be defined to &lt;strong>accept or reject invalidated PO&lt;/strong>.&lt;/li>
&lt;li>A request for a SE selection is defined with SE selector containing at least an AID (to operate through a Select Application APDU command) or an ATR filter. A request for a PO selection could be enhanced to operate after the PO selector processing some APDU commands with the PO : &lt;strong>Select File or Read Records commands&lt;/strong>.&lt;/li>
&lt;li>In case of successful Calypso PO, the matching SE is retuned as a Calypso PO. The Calypso API analyzes the startup information of a Calypso PO in order to identify the kind of product, its revision, the optional features supported, the file structure used. Then for coming PO commands, the setting of the technical parameters automatically managed.&lt;/li>
&lt;/ul>
&lt;p>The PO command grouped with the PO selection have to be “prepared” before the processing of a default or explicit SE selection.&lt;/p>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/calypso/pc/UseCase1_ExplicitSelectionAid/src/main/java/org/eclipse/keyple/example/calypso/pc/usecase1/ExplicitSelectionAid_Pcsc.java" target="_blank" rel="noopener">“Calypso Use Case 1 / Explicit AID Selection”&lt;/a> example&lt;br>
cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/calypso/pc/UseCase2_DefaultSelectionNotification/src/main/java/org/eclipse/keyple/example/calypso/pc/usecase2/DefaultSelectionNotification_Pcsc.java" target="_blank" rel="noopener">“Calypso Use Case 2 / Default Selection Notification”&lt;/a> example&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="../../img/KeypleCalypso-1-Transaction-PO_Selection.png" alt="Calypso - PO Selection scheme" title="Calypso - PO Selection">
A ‘PO resource’ is the set of a Calypso PO and the reader on which it is selected.&lt;/p>
&lt;p>In a same way the Calypso APO provides the tool to select a Calypso security module (a SAM). A SAM selector doesn’t support AID. The corresponding matching SE is a Calypso SAM. A Calypso SAM and the reader used for its selection defines a ‘SAM resource’.&lt;/p>
&lt;h2 id="calypso-secure-transaction">Calypso secure transaction&lt;/h2>
&lt;p>A PO transaction could be operated on a Calypso resource. In case a SAM resource is set, a PO transaction could support the Calypso secure session in order to manage a mutual authentication between the terminal and the Calypso PO.&lt;/p>
&lt;p>Through the PO transaction API, only the APDU commands for the PO are explicitly defined; the APDU commands for the SAM are automatically built by the library. Two kinds of methods are provided by the API: ‘&lt;strong>prepare&lt;/strong>’ methods, and ‘&lt;strong>process&lt;/strong>’ methods.&lt;/p>
&lt;ul>
&lt;li>The ‘prepare’ methods allows to define PO file selection and PO data access operations (read or update of records for a specific file, append of record for a cyclic file, increase or decrease of the value of a counter).&lt;/li>
&lt;li>A ‘process” method sends to the PO at least the previously prepared command.
&lt;ul>
&lt;li>The process PO commands method could operated only if no secure session is currently open with the PO. If one or several PO commands have been prepared, a single request is done to the PO reader.&lt;/li>
&lt;li>The process opening method allows to manage the opening of a secure session.
&lt;ul>
&lt;li>First a single request is operated to the SAM reader in order to set the PO serial as the cryptographic diversifier, and to get the terminal challenge for the session.&lt;/li>
&lt;li>Then another single request is done to the PO reader to play the prepared PO command, and to manage the opening of the PO session.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A process PO command in session method could be processed only if a secure session is already open with PO.
&lt;ul>
&lt;li>A single request Is operated with the PO reader to operate the prepared PO commands.&lt;/li>
&lt;li>Another single request is sent to the SAM reader to update the update the digest of the MAC session.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The process closing method is used to manage the closing of the secure session with the PO.
&lt;ul>
&lt;li>A first SAM request is operated to update the digest of the last prepared PO commands and to get the terminal session certificate (to save a PO request, the API anticipates the responses of the prepared PO commands).&lt;/li>
&lt;li>A single PO request is transmitted to run the last prepared PO command, to recover the PO session certificate, and to send the ratification signal if necessary.&lt;/li>
&lt;li>Finally, a second SAM request allows to authenticate the PO. If the transaction is successful the mutual authentication is valid, and the PO has atomically committed the requested data updates.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The minimal costs of a Calypso secure session are:&lt;/p>
&lt;ul>
&lt;li>3 PO requests (1 for the PO selection + 1 for the PO session opening + 1 for the PO session closing).&lt;/li>
&lt;li>And 3 SAM requests if the SAM is already selected (1 for the PO session opening + 2 for the PO session closing); otherwise 4 SAM requests if the SAM isn’t already selected.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../img/KeypleCalypso-2-Transaction-PO_Session.png" alt="Calypso - PO Transaction scheme" title="Calypso - PO Transaction">&lt;/p>
&lt;p>By default, the PO transaction manages the Calypso secure session as ‘atomic’: the cumulative amount of PO updates command can’t exceed the size of the PO session buffer.&lt;/p>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/calypso/pc/UseCase4_PoAuthentication/src/main/java/org/eclipse/keyple/example/calypso/pc/usecase4/PoAuthentication_Pcsc.java" target="_blank" rel="noopener">“Calypso Use Case 4 / PO Authentication”&lt;/a> example&lt;/p>
&lt;/blockquote>
&lt;p>The PO transaction could also be defined to allow multiple sessions: in this case the transaction is automatically split in several session as necessary.&lt;/p>
&lt;blockquote>
&lt;p>cf.
&lt;a href="https://github.com/eclipse/keyple-java/blob/develop/java/example/calypso/pc/UseCase5_MultipleSession/src/main/java/org/eclipse/keyple/example/calypso/pc/usecase5/MultipleSession_Pcsc.java" target="_blank" rel="noopener">“Calypso Use Case 5 / PO Multiple Session&amp;quot;&lt;/a> example&lt;/p>
&lt;/blockquote></description></item><item><title>Reference APIs</title><link>/keyple-website/docs/reference_apis/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0100</pubDate><guid>/keyple-website/docs/reference_apis/</guid><description>&lt;h1 id="javadoc">JavaDoc&lt;/h1>
&lt;p>The JavaDoc for the Keyple project is available online. The documentation is split into the following parts:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-java-core/index.html">JavaDoc for the Keyple Core API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-java-calypso/index.html">JavaDoc for the Keyple Calypso API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-java-plugin-pcsc/index.html">JavaDoc for the Keyple PC/SC plugin API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-java-plugin-remotese/index.html">JavaDoc for the Keyple Remote SE plugin API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-java-plugin-stub/index.html">JavaDoc for the Keyple Stub plugin API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-android-plugin-nfc/index.html">JavaDoc for the Keyple Android NFC plugin API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/keyple-website/keyple-website/reference/keyple-android-plugin-omapi/index.html">JavaDoc for the Keyple Android OMAPI plugin API&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>